# avisynth - Python AviSynth wrapper
# 
# Copyright 2013, 2016, 2019 the AvsPmod authors <https://github.com/avspmod/avspmod>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
#  http://www.gnu.org/copyleft/gpl.html .

# Dependencies:
#     Python (tested on v2.7)
#     cffi and its dependencies (tested on v0.8.1)
#         pycparser
#         Visual Studio 2008
#     avisynth_c.h (interface 5, or at least 3 + colorspaces from 5,
#                   tested with the header used by x264)
# Optional:
#     global_vars.py (for specifying a custom shared library location)
#
# Notes:
#
# These bindings are NOT compatible with AVISYNTH_INTERFACE_VERSION 3.
#
# Define/undef AVSC_USE_STDCALL on the verify string as needed.
#
# libffi doesn't support passing structs or unions with bit-fields by value.
# To circunvent this some C wrappers were written for the affected functions. 
# This implies compiling a C extension (auto-generated by cffi).
# 
# The bindings uses LoadLibrary. For some reason it crashes for 32-bit. 
# Changing it to use dllimport makes it also work for 32-bit.


import sys
import traceback
import os.path
import collections

import cffi

    


# Try to load the library from the selected directory
try:
    import global_vars
    directory = global_vars.avisynth_library_dir
except:
    directory = ur''
if os.name == 'nt':
    if __debug__:
        if directory:
            ffi = cffi.FFI()
            ffi.cdef('bool SetDllDirectoryW(wchar_t *);')
            kernel32 = ffi.dlopen('kernel32')
            if hasattr(kernel32, 'SetDllDirectoryW'):
                print 'Using a custom AviSynth directory:', directory
                kernel32.SetDllDirectoryW(directory)
            else:
                print ('No SetDllDirectoryW on this version of Windows, '
                       'using AviSynth from PATH')
        else:
            print 'Using AviSynth from PATH'
else: # TODO
    if __debug__:
        if directory:
            print 'Using a custom AvxSynth directory:', directory
        else:
            print 'Using AvxSynth from LD_LIBRARY_PATH'


encoding = sys.getfilesystemencoding()

abi = False

cdef_str = r"""

typedef unsigned char BYTE;
typedef int64_t INT64;
typedef void *PVOID;
typedef PVOID HANDLE;
typedef HANDLE HINSTANCE;
typedef HINSTANCE HMODULE;


enum { AVISYNTH_INTERFACE_VERSION = ... };

enum {AVS_SAMPLE_INT8  = ..., // 1<<0,
      AVS_SAMPLE_INT16 = ..., // 1<<1,
      AVS_SAMPLE_INT24 = ..., // 1<<2,
      AVS_SAMPLE_INT32 = ..., // 1<<3,
      AVS_SAMPLE_FLOAT = ... // 1<<4
};

enum {AVS_PLANAR_Y = ..., // 1<<0,
      AVS_PLANAR_U = ..., // 1<<1,
      AVS_PLANAR_V = ..., // 1<<2,
      AVS_PLANAR_ALIGNED = ..., // 1<<3,
      AVS_PLANAR_Y_ALIGNED = ..., // AVS_PLANAR_Y|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_U_ALIGNED = ..., // AVS_PLANAR_U|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_V_ALIGNED = ..., // AVS_PLANAR_V|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_A = ..., // 1<<4,
      AVS_PLANAR_R = ..., // 1<<5,
      AVS_PLANAR_G = ..., // 1<<6,
      AVS_PLANAR_B = ..., // 1<<7,
      AVS_PLANAR_A_ALIGNED = ..., // AVS_PLANAR_A|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_R_ALIGNED = ..., // AVS_PLANAR_R|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_G_ALIGNED = ..., // AVS_PLANAR_G|AVS_PLANAR_ALIGNED,
      AVS_PLANAR_B_ALIGNED = ... // AVS_PLANAR_B|AVS_PLANAR_ALIGNED
};

  // Colorspace properties.
enum {AVS_CS_BGR = ..., // 1<<28,
      AVS_CS_YUV = ..., // 1<<29,
      AVS_CS_INTERLEAVED = ..., // 1<<30,
      AVS_CS_PLANAR = ..., // 1<<31,
    
      AVS_CS_SHIFT_SUB_WIDTH   = ..., // 0
      AVS_CS_SHIFT_SUB_HEIGHT  = ..., // 1 << 3,
      AVS_CS_SHIFT_SAMPLE_BITS = ..., // 1 << 4,

      AVS_CS_SUB_WIDTH_MASK    = ..., // 7 << AVS_CS_SHIFT_SUB_WIDTH,
      AVS_CS_SUB_WIDTH_1       = ..., // 3 << AVS_CS_SHIFT_SUB_WIDTH, // YV24
      AVS_CS_SUB_WIDTH_2       = ..., // 0 << AVS_CS_SHIFT_SUB_WIDTH, // YV12, I420, YV16
      AVS_CS_SUB_WIDTH_4       = ..., // 1 << AVS_CS_SHIFT_SUB_WIDTH, // YUV9, YV411

      AVS_CS_VPLANEFIRST       = ..., // 1 << 3, // YV12, YV16, YV24, YV411, YUV9
      AVS_CS_UPLANEFIRST       = ..., //1 << 4, // I420

      AVS_CS_SUB_HEIGHT_MASK   = ..., // 7 << AVS_CS_SHIFT_SUB_HEIGHT,
      AVS_CS_SUB_HEIGHT_1      = ..., // 3 << AVS_CS_SHIFT_SUB_HEIGHT, // YV16, YV24, YV411
      AVS_CS_SUB_HEIGHT_2      = ..., // 0 << AVS_CS_SHIFT_SUB_HEIGHT, // YV12, I420
      AVS_CS_SUB_HEIGHT_4      = ..., // 1 << AVS_CS_SHIFT_SUB_HEIGHT, // YUV9

      AVS_CS_SAMPLE_BITS_MASK  = ..., // 7 << AVS_CS_SHIFT_SAMPLE_BITS,
      AVS_CS_SAMPLE_BITS_8     = ..., // 0 << AVS_CS_SHIFT_SAMPLE_BITS,
      AVS_CS_SAMPLE_BITS_16    = ..., // 1 << AVS_CS_SHIFT_SAMPLE_BITS,
      AVS_CS_SAMPLE_BITS_32    = ..., // 2 << AVS_CS_SHIFT_SAMPLE_BITS,

      AVS_CS_PLANAR_MASK       = ..., // AVS_CS_PLANAR | AVS_CS_INTERLEAVED | AVS_CS_YUV | AVS_CS_BGR | AVS_CS_SAMPLE_BITS_MASK | AVS_CS_SUB_HEIGHT_MASK | AVS_CS_SUB_WIDTH_MASK,
      AVS_CS_PLANAR_FILTER     = ... // ~( AVS_CS_VPLANEFIRST | AVS_CS_UPLANEFIRST )
};

  // Specific colorformats
enum {
  AVS_CS_UNKNOWN = 0,
  AVS_CS_BGR24 = ..., // 1<<0 | AVS_CS_BGR | AVS_CS_INTERLEAVED,
  AVS_CS_BGR32 = ..., // 1<<1 | AVS_CS_BGR | AVS_CS_INTERLEAVED,
  AVS_CS_YUY2 = ..., // 1<<2 | AVS_CS_YUV | AVS_CS_INTERLEAVED,
  //  AVS_CS_YV12  = 1<<3  Reserved
  //  AVS_CS_I420  = 1<<4  Reserved
  AVS_CS_RAW32 = ..., // 1<<5 | AVS_CS_INTERLEAVED,

  AVS_CS_YV24  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_1,  // YVU 4:4:4 planar
  AVS_CS_YV16  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_2,  // YVU 4:2:2 planar
  AVS_CS_YV12  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_2 | AVS_CS_SUB_WIDTH_2,  // YVU 4:2:0 planar
  AVS_CS_I420  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_UPLANEFIRST | AVS_CS_SUB_HEIGHT_2 | AVS_CS_SUB_WIDTH_2,  // YUV 4:2:0 planar
  AVS_CS_IYUV  = ..., // AVS_CS_I420,
  AVS_CS_YV411 = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_1 | AVS_CS_SUB_WIDTH_4,  // YVU 4:1:1 planar
  AVS_CS_YUV9  = ..., // AVS_CS_PLANAR | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8 | AVS_CS_VPLANEFIRST | AVS_CS_SUB_HEIGHT_4 | AVS_CS_SUB_WIDTH_4,  // YVU 4:1:0 planar
  AVS_CS_Y8    = ..., // AVS_CS_PLANAR | AVS_CS_INTERLEAVED | AVS_CS_YUV | AVS_CS_SAMPLE_BITS_8                                              // Y   4:0:0 planar
};

enum {
  AVS_IT_BFF = ..., // 1<<0,
  AVS_IT_TFF = ..., // 1<<1,
  AVS_IT_FIELDBASED = ... // 1<<2
};

enum {
  AVS_FILTER_TYPE=1,
  AVS_FILTER_INPUT_COLORSPACE=2,
  AVS_FILTER_OUTPUT_TYPE=9,
  AVS_FILTER_NAME=4,
  AVS_FILTER_AUTHOR=5,
  AVS_FILTER_VERSION=6,
  AVS_FILTER_ARGS=7,
  AVS_FILTER_ARGS_INFO=8,
  AVS_FILTER_ARGS_DESCRIPTION=10,
  AVS_FILTER_DESCRIPTION=11};

enum {  //SUBTYPES
  AVS_FILTER_TYPE_AUDIO=1,
  AVS_FILTER_TYPE_VIDEO=2,
  AVS_FILTER_OUTPUT_TYPE_SAME=3,
  AVS_FILTER_OUTPUT_TYPE_DIFFERENT=4};

enum {
  AVS_CACHE_NOTHING=0,
  AVS_CACHE_RANGE=1,
  AVS_CACHE_ALL=2,
  AVS_CACHE_AUDIO=3,
  AVS_CACHE_AUDIO_NONE=4,
  AVS_CACHE_AUDIO_AUTO=5
  };

#define AVS_FRAME_ALIGN ...

typedef struct AVS_Clip AVS_Clip;
typedef struct AVS_ScriptEnvironment AVS_ScriptEnvironment;

/////////////////////////////////////////////////////////////////////
//
// AVS_VideoInfo
//

// AVS_VideoInfo is layed out identicly to VideoInfo
typedef struct AVS_VideoInfo {
  int width, height;    // width=0 means no video
  unsigned fps_numerator, fps_denominator;
  int num_frames;

  int pixel_type;
  
  int audio_samples_per_second;   // 0 means no audio
  int sample_type;
  INT64 num_audio_samples;
  int nchannels;

  // Imagetype properties

  int image_type;
} AVS_VideoInfo;

// useful functions of the above
int avs_has_video(const AVS_VideoInfo * p);
int avs_has_audio(const AVS_VideoInfo * p);
int avs_is_rgb(const AVS_VideoInfo * p);
int avs_is_rgb24(const AVS_VideoInfo * p); // Clear out additional properties
int avs_is_rgb32(const AVS_VideoInfo * p);
int avs_is_yuv(const AVS_VideoInfo * p);
int avs_is_yuy2(const AVS_VideoInfo * p);
int avs_is_yv24(const AVS_VideoInfo * p);
int avs_is_yv16(const AVS_VideoInfo * p);
int avs_is_yv12(const AVS_VideoInfo * p);
int avs_is_yv411(const AVS_VideoInfo * p);
int avs_is_y8(const AVS_VideoInfo * p);
int avs_is_property(const AVS_VideoInfo * p, int property);
int avs_is_planar(const AVS_VideoInfo * p);
int avs_is_color_space(const AVS_VideoInfo * p, int c_space);
int avs_is_field_based(const AVS_VideoInfo * p);
int avs_is_parity_known(const AVS_VideoInfo * p);
int avs_is_bff(const AVS_VideoInfo * p);
int avs_is_tff(const AVS_VideoInfo * p);
int avs_bits_per_pixel(const AVS_VideoInfo * p);
int avs_bytes_from_pixels(const AVS_VideoInfo * p, int pixels); // Will work on planar images, but will return only luma planes
int avs_row_size(const AVS_VideoInfo * p);  // Also only returns first plane on planar images
int avs_bmp_size(const AVS_VideoInfo * vi);
int avs_samples_per_second(const AVS_VideoInfo * p);
int avs_bytes_per_channel_sample(const AVS_VideoInfo * p);
int avs_bytes_per_audio_sample(const AVS_VideoInfo * p);
INT64 avs_audio_samples_from_frames(const AVS_VideoInfo * p, INT64 frames);
int avs_frames_from_audio_samples(const AVS_VideoInfo * p, INT64 samples);
INT64 avs_audio_samples_from_bytes(const AVS_VideoInfo * p, INT64 bytes);
INT64 avs_bytes_from_audio_samples(const AVS_VideoInfo * p, INT64 samples);
int avs_audio_channels(const AVS_VideoInfo * p);
int avs_sample_type(const AVS_VideoInfo * p);
void avs_set_property(AVS_VideoInfo * p, int property); // useful mutator
void avs_clear_property(AVS_VideoInfo * p, int property);
void avs_set_field_based(AVS_VideoInfo * p, int isfieldbased);
void avs_set_fps(AVS_VideoInfo * p, unsigned numerator, unsigned denominator);
int avs_is_same_colorspace(AVS_VideoInfo * x, AVS_VideoInfo * y);


/////////////////////////////////////////////////////////////////////
//
// AVS_VideoFrame
//

// VideoFrameBuffer holds information about a memory block which is used
// for video data.  For efficiency, instances of this class are not deleted
// when the refcount reaches zero; instead they're stored in a linked list
// to be reused.  The instances are deleted when the corresponding AVS
// file is closed.

// AVS_VideoFrameBuffer is layed out identicly to VideoFrameBuffer
// DO NOT USE THIS STRUCTURE DIRECTLY
typedef struct AVS_VideoFrameBuffer {
  BYTE * data;
  int data_size;
  // sequence_number is incremented every time the buffer is changed, so
  // that stale views can tell they're no longer valid.
  volatile long sequence_number;

  volatile long refcount;
} AVS_VideoFrameBuffer;

// VideoFrame holds a "window" into a VideoFrameBuffer.

// AVS_VideoFrame is layed out identicly to IVideoFrame
// DO NOT USE THIS STRUCTURE DIRECTLY
typedef struct AVS_VideoFrame {
  volatile long refcount;
  AVS_VideoFrameBuffer * vfb;
  int offset, pitch, row_size, height, offsetU, offsetV, pitchUV;  // U&V offsets are from top of picture.
  int row_sizeUV, heightUV; // XXX: only on interface 5
} AVS_VideoFrame;


// Access functions for AVS_VideoFrame
int avs_get_pitch(const AVS_VideoFrame * p);
int avs_get_pitch_p(const AVS_VideoFrame * p, int plane);
int avs_get_row_size(const AVS_VideoFrame * p);
int avs_get_row_size_p(const AVS_VideoFrame * p, int plane);
int avs_get_height(const AVS_VideoFrame * p);
int avs_get_height_p(const AVS_VideoFrame * p, int plane);
const BYTE* avs_get_read_ptr(const AVS_VideoFrame * p);
const BYTE* avs_get_read_ptr_p(const AVS_VideoFrame * p, int plane);
int avs_is_writable(const AVS_VideoFrame * p);
BYTE* avs_get_write_ptr(const AVS_VideoFrame * p);
BYTE* avs_get_write_ptr_p(const AVS_VideoFrame * p, int plane);


typedef void (*avs_release_video_frame_func)(AVS_VideoFrame *);
// makes a shallow copy of a video frame
typedef AVS_VideoFrame * (*avs_copy_video_frame_func)(AVS_VideoFrame *);


/////////////////////////////////////////////////////////////////////
//
// AVS_Value
//

// Treat AVS_Value as a fat pointer.  That is use avs_copy_value
// and avs_release_value appropiaty as you would if AVS_Value was
// a pointer.

// To maintain source code compatibility with future versions of the
// avisynth_c API don't use the AVS_Value directly.  Use the helper
// functions below.

// AVS_Value is layed out identicly to AVSValue
typedef struct AVS_Value AVS_Value;
struct AVS_Value {
  short type;  // 'a'rray, 'c'lip, 'b'ool, 'i'nt, 'f'loat, 's'tring, 'v'oid, or 'l'ong
               // for some function e'rror
  short array_size;
  union {
    void * clip; // do not use directly, use avs_take_clip
    char boolean;
    int integer;
    float floating_pt;
    const char * string;
    const AVS_Value * array;
  } d;
};

// AVS_Value should be initilized with avs_void.
// Should also set to avs_void after the value is released
// with avs_copy_value.  Consider it the equalvent of setting
// a pointer to NULL
static const AVS_Value avs_void = {'v'};
static const AVS_Value * avs_void_p;

//typedef void (*avs_copy_value_func)(AVS_Value * dest, AVS_Value src);
void avs_copy_value_w(AVS_Value * dest, AVS_Value * src);
//typedef void (*avs_release_value_func)(AVS_Value);
void avs_release_value_w(AVS_Value *);

//int avs_defined(AVS_Value v);
int avs_defined_w(AVS_Value *v);
//int avs_is_clip(AVS_Value v);
int avs_is_clip_w(AVS_Value *v);
//int avs_is_bool(AVS_Value v);
int avs_is_bool_w(AVS_Value *v);
//int avs_is_int(AVS_Value v);
int avs_is_int_w(AVS_Value *v);
//int avs_is_float(AVS_Value v);
int avs_is_float_w(AVS_Value *v);
//int avs_is_string(AVS_Value v);
int avs_is_string_w(AVS_Value *v);
//int avs_is_array(AVS_Value v);
int avs_is_array_w(AVS_Value *v);
//int avs_is_error(AVS_Value v);
int avs_is_error_w(AVS_Value *v);

//typedef AVS_Clip * (*avs_take_clip_func)(AVS_Value, AVS_ScriptEnvironment *);
AVS_Clip * avs_take_clip_w(AVS_Value *, AVS_ScriptEnvironment *);
typedef void (*avs_set_to_clip_func)(AVS_Value *, AVS_Clip *);

//int avs_as_bool(AVS_Value v);
int avs_as_bool_w(AVS_Value *v);
//int avs_as_int(AVS_Value v);
int avs_as_int_w(AVS_Value *v);
//const char * avs_as_string(AVS_Value v);
const char * avs_as_string_w(AVS_Value *v);
//double avs_as_float(AVS_Value v);
double avs_as_float_w(AVS_Value *v);
//const char * avs_as_error(AVS_Value v);
const char * avs_as_error_w(AVS_Value *v);
//const AVS_Value * avs_as_array(AVS_Value v);
const AVS_Value * avs_as_array_w(AVS_Value *v);
//int avs_array_size(AVS_Value v);
int avs_array_size_w(AVS_Value *v);
//AVS_Value avs_array_elt(AVS_Value v, int index);
AVS_Value * avs_array_elt_w(AVS_Value *v, int index);

// only use these functions on an AVS_Value that does not already have
// an active value.  Remember, treat AVS_Value as a fat pointer.
//AVS_Value avs_new_value_bool(int v0);
void avs_new_value_bool_w(int v0, AVS_Value * v);
//AVS_Value avs_new_value_int(int v0);
void avs_new_value_int_w(int v0, AVS_Value * v);
//AVS_Value avs_new_value_string(const char * v0);
void avs_new_value_string_w(const char * v0, AVS_Value * v);
//AVS_Value avs_new_value_float(float v0);
void avs_new_value_float_w(float v0, AVS_Value * v);
//AVS_Value avs_new_value_error(const char * v0);
void avs_new_value_error_w(const char * v0, AVS_Value * v);
//AVS_Value avs_new_value_clip(AVS_Clip * v0);
void avs_new_value_clip_w(AVS_Clip * v0, AVS_Value * v);
//AVS_Value avs_new_value_array(AVS_Value * v0, int size);
void avs_new_value_array_w(AVS_Value * v0, int size, AVS_Value * v);


/////////////////////////////////////////////////////////////////////
//
// AVS_Clip
//

typedef void (*avs_release_clip_func)(AVS_Clip *);
typedef AVS_Clip * (*avs_copy_clip_func)(AVS_Clip *);

typedef const char * (*avs_clip_get_error_func)(AVS_Clip *); // return 0 if no error

typedef const AVS_VideoInfo * (*avs_get_video_info_func)(AVS_Clip *);

typedef int (*avs_get_version_func)(AVS_Clip *);
 
typedef AVS_VideoFrame * (*avs_get_frame_func)(AVS_Clip *, int n);
// The returned video frame must be released with avs_release_video_frame

typedef int (*avs_get_parity_func)(AVS_Clip *, int n); 
// return field parity if field_based, else parity of first field in frame

typedef int (*avs_get_audio_func)(AVS_Clip *, void * buf, 
                             INT64 start, INT64 count); 
// start and count are in samples

typedef int (*avs_set_cache_hints_func)(AVS_Clip *, 
                                   int cachehints, int frame_range);

// XXX: AVS_ApplyFunc left out


// XXX: AVS_FilterInfo left out

// Create a new filter
// fi is set to point to the AVS_FilterInfo so that you can
//   modify it once it is initilized.
// store_child should generally be set to true.  If it is not
//    set than ALL methods (the function pointers) must be defined
// If it is set than you do not need to worry about freeing the child
//    clip.
typedef AVS_Clip * (*avs_new_c_filter_func)(AVS_ScriptEnvironment * e,
                                       void * * fi,
                                       void * child, int store_child);


/////////////////////////////////////////////////////////////////////
//
// AVS_ScriptEnvironment
//

// For GetCPUFlags.  These are backwards-compatible with those in VirtualDub.
enum {                    
                                /* slowest CPU to support extension */
  AVS_CPU_FORCE        = 0x01,   // N/A
  AVS_CPU_FPU          = 0x02,   // 386/486DX
  AVS_CPU_MMX          = 0x04,   // P55C, K6, PII
  AVS_CPU_INTEGER_SSE  = 0x08,   // PIII, Athlon
  AVS_CPU_SSE          = 0x10,   // PIII, Athlon XP/MP
  AVS_CPU_SSE2         = 0x20,   // PIV, Hammer
  AVS_CPU_3DNOW        = 0x40,   // K6-2
  AVS_CPU_3DNOW_EXT    = 0x80,   // Athlon
  AVS_CPU_X86_64       = 0xA0,   // Hammer (note: equiv. to 3DNow + SSE2, 
                                 // which only Hammer will have anyway)
  AVS_CPUF_SSE3       = 0x100,   //  PIV+, K8 Venice
  AVS_CPUF_SSSE3      = 0x200,   //  Core 2
  AVS_CPUF_SSE4       = 0x400,   //  Penryn, Wolfdale, Yorkfield
  AVS_CPUF_SSE4_1     = 0x400,
  AVS_CPUF_SSE4_2     = 0x800,   //  Nehalem
};

typedef const char * (*avs_get_error_func)(AVS_ScriptEnvironment *); // return 0 if no error

typedef long (*avs_get_cpu_flags_func)(AVS_ScriptEnvironment *);
typedef int (*avs_check_version_func)(AVS_ScriptEnvironment *, int version);

typedef char * (*avs_save_string_func)(AVS_ScriptEnvironment *, const char* s, int length);
typedef char * (*avs_sprintf_func)(AVS_ScriptEnvironment *, const char * fmt, ...);

typedef char * (*avs_vsprintf_func)(AVS_ScriptEnvironment *, const char * fmt, void* val);
 // note: val is really a va_list; I hope everyone typedefs va_list to a pointer

typedef int (*avs_add_function_func)(AVS_ScriptEnvironment *, 
                                const char * name, const char * params, 
                                void * apply, void * user_data);


typedef int (*avs_function_exists_func)(AVS_ScriptEnvironment *, const char * name);

//typedef AVS_Value (*avs_invoke_func)(AVS_ScriptEnvironment *, const char * name, AVS_Value args, const char** arg_names);
void avs_invoke_w(AVS_ScriptEnvironment *, const char * name, AVS_Value *args, const char** arg_names, AVS_Value *v);
// The returned value must be be released with avs_release_value

//typedef AVS_Value (*avs_get_var_func)(AVS_ScriptEnvironment *, const char* name);
void avs_get_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* v);
// The returned value must be be released with avs_release_value

//typedef int (*avs_set_var_func)(AVS_ScriptEnvironment *, const char* name, AVS_Value val);
int avs_set_var_w(AVS_ScriptEnvironment *, const char* name, AVS_Value* val);

//typedef int (*avs_set_global_var_func)(AVS_ScriptEnvironment *, const char* name, AVS_Value val);
int avs_set_global_var_w(AVS_ScriptEnvironment *, const char* name, const AVS_Value* val);

//void avs_push_context(AVS_ScriptEnvironment *, int level=0);
//void avs_pop_context(AVS_ScriptEnvironment *);

typedef AVS_VideoFrame * (*avs_new_video_frame_a_func)(AVS_ScriptEnvironment *, 
                                          const AVS_VideoInfo * vi, int align);
// align should be at least 16

typedef int (*avs_make_writable_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * * pvf);

typedef void (*avs_bit_blt_func)(AVS_ScriptEnvironment *, BYTE* dstp, int dst_pitch, const BYTE* srcp, int src_pitch, int row_size, int height);

typedef void (*AVS_ShutdownFunc)(void* user_data, AVS_ScriptEnvironment * env);
typedef void (*avs_at_exit_func)(AVS_ScriptEnvironment *, AVS_ShutdownFunc function, void * user_data);

typedef AVS_VideoFrame * (*avs_subframe_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * src, int rel_offset, int new_pitch, int new_row_size, int new_height);
// The returned video frame must be be released

typedef int (*avs_set_memory_max_func)(AVS_ScriptEnvironment *, int mem);

typedef int (*avs_set_working_dir_func)(AVS_ScriptEnvironment *, const char * newdir);

// avisynth.dll exports this; it's a way to use it as a library, without
// writing an AVS script or without going through AVIFile.
typedef AVS_ScriptEnvironment * (*avs_create_script_environment_func)(int version);


typedef void (*avs_delete_script_environment_func)(AVS_ScriptEnvironment *);


typedef AVS_VideoFrame * (*avs_subframe_planar_func)(AVS_ScriptEnvironment *, AVS_VideoFrame * src, int rel_offset, int new_pitch, int new_row_size, int new_height, int rel_offsetU, int rel_offsetV, int new_pitchUV);
// The returned video frame must be be released


void* malloc(size_t);
void free(void*);

HMODULE LoadLibrary(const char*);
void* GetProcAddress(HMODULE, const char*);
void FreeLibrary(HMODULE);

typedef struct AVS_Library{ ...; } AVS_Library;

avs_add_function_func avs_add_function;
avs_at_exit_func avs_at_exit;
avs_bit_blt_func avs_bit_blt;
avs_check_version_func avs_check_version;
avs_clip_get_error_func avs_clip_get_error;
avs_copy_clip_func avs_copy_clip;
avs_copy_video_frame_func avs_copy_video_frame;
avs_create_script_environment_func avs_create_script_environment;
avs_delete_script_environment_func avs_delete_script_environment;
avs_function_exists_func avs_function_exists;
avs_get_audio_func avs_get_audio;
avs_get_cpu_flags_func avs_get_cpu_flags;
avs_get_error_func avs_get_error;
avs_get_frame_func avs_get_frame;
avs_get_parity_func avs_get_parity;
avs_get_version_func avs_get_version;
avs_get_video_info_func avs_get_video_info;
avs_make_writable_func avs_make_writable;
avs_new_c_filter_func avs_new_c_filter;
avs_new_video_frame_a_func avs_new_video_frame_a;
avs_release_clip_func avs_release_clip;
avs_release_video_frame_func avs_release_video_frame;
avs_save_string_func avs_save_string;
avs_set_cache_hints_func avs_set_cache_hints;
avs_set_memory_max_func avs_set_memory_max;
avs_set_working_dir_func avs_set_working_dir;
avs_sprintf_func avs_sprintf;
avs_subframe_func avs_subframe;
avs_subframe_planar_func avs_subframe_planar;
avs_vsprintf_func avs_vsprintf;

;AVS_Library * avs_load_library();
AVS_Library * avs_load_library_w();
void avs_free_library(AVS_Library *library);

AVS_Library * library;
"""

verify_str = r"""
#pragma warning(disable: 4028 4047) // because of the function ptr hack
#include <windows.h>
#define AVSC_NO_DECLSPEC
#include "avisynth_c.h"

AVS_Library * library;

static const AVS_Value * avs_void_p = &avs_void;


// no wrapper needed for the following functions

avs_add_function_func avs_add_function;
avs_at_exit_func avs_at_exit;
avs_bit_blt_func avs_bit_blt;
avs_check_version_func avs_check_version;
avs_clip_get_error_func avs_clip_get_error;
avs_copy_clip_func avs_copy_clip;
avs_copy_video_frame_func avs_copy_video_frame;
avs_create_script_environment_func avs_create_script_environment;
avs_delete_script_environment_func avs_delete_script_environment;
avs_function_exists_func avs_function_exists;
avs_get_audio_func avs_get_audio;
avs_get_cpu_flags_func avs_get_cpu_flags;
avs_get_error_func avs_get_error;
avs_get_frame_func avs_get_frame;
avs_get_parity_func avs_get_parity;
avs_get_version_func avs_get_version;
avs_get_video_info_func avs_get_video_info;
avs_make_writable_func avs_make_writable;
avs_new_c_filter_func avs_new_c_filter;
avs_new_video_frame_a_func avs_new_video_frame_a;
avs_release_clip_func avs_release_clip;
avs_release_video_frame_func avs_release_video_frame;
avs_save_string_func avs_save_string;
avs_set_cache_hints_func avs_set_cache_hints;
avs_set_memory_max_func avs_set_memory_max;
avs_set_working_dir_func avs_set_working_dir;
avs_sprintf_func avs_sprintf;
avs_subframe_func avs_subframe;
avs_subframe_planar_func avs_subframe_planar;
avs_vsprintf_func avs_vsprintf;

AVS_Library * avs_load_library_w(){
    library = avs_load_library();
    if (library == NULL)
        return NULL;
    avs_add_function=library->avs_add_function;
    avs_at_exit=library->avs_at_exit;
    avs_bit_blt=library->avs_bit_blt;
    avs_check_version=library->avs_check_version;
    avs_clip_get_error=library->avs_clip_get_error;
    avs_copy_clip=library->avs_copy_clip;
    avs_copy_video_frame=library->avs_copy_video_frame;
    avs_create_script_environment=library->avs_create_script_environment;
    avs_function_exists=library->avs_function_exists;
    avs_delete_script_environment=library->avs_delete_script_environment;
    avs_get_audio=library->avs_get_audio;
    avs_get_cpu_flags=library->avs_get_cpu_flags;
    avs_get_error=library->avs_get_error;
    avs_get_frame=library->avs_get_frame;
    avs_get_parity=library->avs_get_parity;
    avs_get_version=library->avs_get_version;
    avs_get_video_info=library->avs_get_video_info;
    avs_make_writable=library->avs_make_writable;
    avs_new_c_filter=library->avs_new_c_filter;
    avs_new_video_frame_a=library->avs_new_video_frame_a;
    avs_release_clip=library->avs_release_clip;
    avs_release_video_frame=library->avs_release_video_frame;
    avs_save_string=library->avs_save_string;
    avs_set_cache_hints=library->avs_set_cache_hints;
    avs_set_memory_max=library->avs_set_memory_max;
    avs_set_working_dir=library->avs_set_working_dir;
    avs_sprintf=library->avs_sprintf;
    avs_subframe=library->avs_subframe;
    avs_subframe_planar=library->avs_subframe_planar;
    avs_vsprintf=library->avs_vsprintf;
    return library;
}

// wrapped functions


// AVS_Value

void avs_copy_value_w(AVS_Value * dest, AVS_Value * src){
    library->avs_copy_value(dest, *src);
}
void avs_release_value_w(AVS_Value *value){
    library->avs_release_value(*value);
}

int avs_defined_w(AVS_Value *v){return avs_defined(*v);}
int avs_is_clip_w(AVS_Value *v){return avs_is_clip(*v);}
int avs_is_bool_w(AVS_Value *v){return avs_is_bool(*v);}
int avs_is_int_w(AVS_Value *v){return avs_is_int(*v);}
int avs_is_float_w(AVS_Value *v){return avs_is_float(*v);}
int avs_is_string_w(AVS_Value *v){return avs_is_string(*v);}
int avs_is_array_w(AVS_Value *v){return avs_is_array(*v);}
int avs_is_error_w(AVS_Value *v){return avs_is_error(*v);}

AVS_Clip * avs_take_clip_w(AVS_Value *val, AVS_ScriptEnvironment *env){
    return library->avs_take_clip(*val, env);
}

int avs_as_bool_w(AVS_Value *v){return avs_as_bool(*v);}
int avs_as_int_w(AVS_Value *v){return avs_as_int(*v);}
const char * avs_as_string_w(AVS_Value *v){return avs_as_string(*v);}
double avs_as_float_w(AVS_Value *v){return avs_as_float(*v);}
const char * avs_as_error_w(AVS_Value *v){return avs_as_error(*v);}
const AVS_Value * avs_as_array_w(AVS_Value *v){return avs_as_array(*v);}
int avs_array_size_w(AVS_Value *v){return avs_array_size(*v);}
AVS_Value * avs_array_elt_w(AVS_Value *v, int index){
    return avs_is_array(*v)? &((*v).d.array[index]): v;
}


// AVS_ScriptEnvironment

void avs_invoke_w(AVS_ScriptEnvironment *env, const char * name, 
                  AVS_Value *args, const char** arg_names, AVS_Value *val){
    AVS_Value ret = library->avs_invoke(env, name, *args, arg_names);
    library->avs_copy_value(val, ret);
    library->avs_release_value(ret);
    library->avs_copy_value(&ret, avs_void);
}

void avs_get_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* val){
    AVS_Value ret = library->avs_get_var(env, name);
    library->avs_copy_value(val, ret);
    library->avs_release_value(ret);
    library->avs_copy_value(&ret, avs_void);
}
int avs_set_var_w(AVS_ScriptEnvironment *env, const char* name, AVS_Value* val){
    return library->avs_set_var(env, name, *val);
}
int avs_set_global_var_w(AVS_ScriptEnvironment *env, const char* name, 
                         const AVS_Value* val){
    return library->avs_set_global_var(env, name, *val);
}

void avs_new_value_bool_w(int v0, AVS_Value * v){
    (*v).type = 'b'; 
    (*v).d.boolean = v0 == 0 ? 0 : 1;
}   
void avs_new_value_int_w(int v0, AVS_Value * v){
    (*v).type = 'i'; 
    (*v).d.integer = v0;
}   
void avs_new_value_string_w(const char * v0, AVS_Value * v){
    (*v).type = 's'; 
    (*v).d.string = v0;
}   
void avs_new_value_float_w(float v0, AVS_Value * v){
    (*v).type = 'f'; 
    (*v).d.floating_pt = v0;
}   
void avs_new_value_error_w(const char * v0, AVS_Value * v){
    (*v).type = 'e'; 
    (*v).d.string = v0;
}   
void avs_new_value_clip_w(AVS_Clip * v0, AVS_Value * v){
    library->avs_set_to_clip(v, v0);
}
void avs_new_value_array_w(AVS_Value * v0, int size, AVS_Value * v){
    (*v).type = 'a'; 
    (*v).d.array = v0;
    (*v).array_size = size;
}   

"""

ffi = cffi.FFI()
ffi.cdef(cdef_str)
if abi: # TODO
    avs = ffi.dlopen('avisynth')
else:
    avs = ffi.verify(verify_str, libraries=[], library_dirs=[],
        modulename=os.path.splitext(__file__)[0] + '_ext', # comment out on debugging
        )
    if avs.avs_load_library_w() == ffi.NULL:
        raise OSError(*ffi.getwinerror())
    avs.library = avs.avs_load_library_w()

class AVS_VideoInfo(object):
    
    def __init__(self, vi=None):
        self.cdata = vi or ffi.new('AVS_VideoInfo *')
        for field, value in ffi.typeof(self.cdata[0]).fields:
            setattr(self, field, getattr(self.cdata, field))
    
    def __str__(self):
        string = str(self.__class__)
        for field, value in ffi.typeof(self.cdata[0]).fields:
            string += ', {0}: {1}'.format(field, getattr(self.cdata, field))
        return string
    
    def has_video(self):
        return avs.avs_has_video(self.cdata)
    
    def has_audio(self):
        return avs.avs_has_audio(self.cdata)
    
    def is_rgb(self):
        return bool(avs.avs_is_rgb(self.cdata))
    
    def is_rgb24(self):
        return bool(avs.avs_is_rgb24(self.cdata))
    
    def is_rgb32(self):
        return bool(avs.avs_is_rgb32(self.cdata))
    
    def is_yuv(self):
        return bool(avs.avs_is_yuv(self.cdata))
    
    def is_yuy2(self):
        return bool(avs.avs_is_yuy2(self.cdata))
    
    def is_yv24(self):
        return bool(avs.avs_is_yv24(self.cdata))
    
    def is_yv16(self):
        return bool(avs.avs_is_yv16(self.cdata))
    
    def is_yv12(self):
        return bool(avs.avs_is_yv12(self.cdata))
    
    def is_yv411(self):
        return bool(avs.avs_is_yv411(self.cdata))
    
    def is_y8(self):
        return bool(avs.avs_is_y8(self.cdata))
    
    def is_property(self, property):
        return bool(avs.avs_is_yuy2(self.cdata, property))
    
    def is_planar(self):
        return bool(avs.avs_is_planar(self.cdata))
    
    def is_color_space(self, color_space):
        return bool(avs.avs_is_color_space(self.cdata, color_space))
    
    def is_field_based(self):
        return bool(avs.avs_is_field_based(self.cdata))
    
    def is_parity_known(self):
        return bool(avs.avs_is_parity_known(self.cdata))
    
    def is_bff(self):
        return bool(avs.avs_is_bff(self.cdata))
    
    def is_tff(self):
        return bool(avs.avs_is_tff(self.cdata))
    
    def is_v_plane_first(self): # interface.cpp
        return not self.is_y8() and self.is_planar() and (self.pixel_type & \
            (avs.AVS_CS_VPLANEFIRST | avs.AVS_CS_UPLANEFIRST)) \
            == avs.AVS_CS_VPLANEFIRST # Shouldn't use this
    
    def get_plane_width_subsampling(self, plane): # interface.cpp
        """Subsampling in bitshifts"""
        if plane == avs.AVS_PLANAR_Y:  # No subsampling
            return 0
        if self.is_y8():
            raise AvisynthError('Filter error: get_plane_width_subsampling not '
                                'available on Y8 pixel type.')
        if (plane == avs.AVS_PLANAR_U or plane == avs.AVS_PLANAR_V):
            if self.is_yuy2():
                return 1
            elif self.is_planar():
                return ((self.pixel_type >> avs.AVS_CS_SHIFT_SUB_WIDTH) + 1) & 3
            else:
                raise AvisynthError('Filter error: get_plane_width_subsampling '
                                    'called with unsupported pixel type.')
        raise AvisynthError('Filter error: get_plane_width_subsampling called '
                            'with unsupported plane.')
    
    def get_plane_height_subsampling(self, plane): # interface.cpp
        """Subsampling in bitshifts"""
        if plane == avs.AVS_PLANAR_Y:  # No subsampling
            return 0
        if self.is_y8():
            raise AvisynthError('Filter error: get_plane_height_subsampling not '
                                'available on Y8 pixel type.')
        if (plane == avs.AVS_PLANAR_U or plane == avs.AVS_PLANAR_V):
            if self.is_yuy2():
                return 0
            elif self.is_planar():
                return ((self.pixel_type >> avs.AVS_CS_SHIFT_SUB_HEIGHT) + 1) & 3
            else:
                raise AvisynthError('Filter error: get_plane_height_subsampling '
                                    'called with unsupported pixel type.')
        raise AvisynthError('Filter error: get_plane_height_subsampling called '
                            'with unsupported plane.')    
    
    def bits_per_pixel(self):
        return avs.avs_bits_per_pixel(self.cdata)
    
    def bytes_from_pixels(self, pixels):
        # Will work on planar images, but will return only luma planes
        return avs.avs_bytes_from_pixels(self.cdata, pixels)
    
    def row_size(self):
        # Also only returns first plane on planar images
        return avs.avs_row_size(self.cdata)
    
    def bmp_size(self):
        return avs.avs_bmp_size(self.cdata)
    
    def samples_per_second(self):
        return avs.avs_samples_per_second(self.cdata)
    
    def is_sample_type(self, testtype): # interface.cpp
        return (self.cdata.sample_type & testtype) != 0
    
    def bytes_per_channel_sample(self):
        return avs.avs_bytes_per_channel_sample(self.cdata)
    
    def bytes_per_audio_sample(self):
        return avs.avs_bytes_per_audio_sample(self.cdata)
    
    def audio_samples_from_frames(self, frames):
        return avs.avs_audio_samples_from_frames(self.cdata, frames)
    
    def frames_from_audio_samples(self, samples):
        return avs.avs_frames_from_audio_samples(self.cdata, samples)
    
    def audio_samples_from_bytes(self, bytes):
        return avs.avs_audio_samples_from_bytes(self.cdata, bytes)
    
    def bytes_from_audio_samples(self, samples):
        return avs.avs_bytes_from_audio_samples(self.cdata, samples)
    
    def audio_channels(self):
        return avs.avs_audio_channels(self.cdata)
    
    def sample_type(self):
        return avs.avs_sample_type(self.cdata)
    
    def set_property(self, property):
        # useful mutator
        avs.avs_set_property(self.cdata, property)
    
    def clear_property(self, property):
        avs.avs_clear_property(self.cdata, property)
    
    def set_field_based(self, is_field_based):
        avs.avs_set_field_based(self.cdata, is_field_based)
    
    def set_fps(self, numerator, denominator):
        avs.avs_set_fps(self.cdata, numerator, denominator)
    
    def is_same_colorspace(self, vi):
        return bool(avs.avs_is_same_colorspace(self.cdata, vi))


class AVS_VideoFrame(object):
    
    def __init__(self, vf):
        self.cdata = vf
    
    def __del__(self):
        avs.avs_release_video_frame(self.cdata)
    
    def copy(self):
        """makes a shallow copy of a video frame"""
        return avs.avs_copy_video_frame(self.cdata)
    
    def __str__(self):
        string = str(self.__class__)
        for field, value in ffi.typeof(self.cdata[0]).fields:
            string += ', {0}: {1}'.format(field, getattr(self.cdata, field))
        return string
    
    def get_pitch(self, plane=avs.AVS_PLANAR_Y):
        # U&V offsets are from top of picture
        return avs.avs_get_pitch_p(self.cdata, plane)
    
    def get_row_size(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_row_size_p(self.cdata, plane)
    
    def get_height(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_height_p(self.cdata, plane)
    
    def get_frame_buffer(self): # interface.cpp
        return self.cdata.vfb
    
    def get_offset(self, plane=avs.AVS_PLANAR_Y): # interface.cpp
        if plane == avs.AVS_PLANAR_U: return self.cdata.offsetU
        elif plane == avs.AVS_PLANAR_V: return self.cdata.offsetV
        return self.cdata.offset
    
    def get_read_ptr(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_read_ptr_p(self.cdata, plane)
    
    def is_writable(self):
        return bool(avs.avs_is_writable(self.cdata))
    
    def get_write_ptr(self, plane=avs.AVS_PLANAR_Y):
        return avs.avs_get_write_ptr_p(self.cdata, plane)


class AVS_Value(object):
    
    def __init__(self, value=None, env=None, release_on_del=True):
        self.cdata = ffi.new('AVS_Value *', avs.avs_void)
        self.env = env # for using with clips, we assume all belong to the same env 
        self._release_on_del = release_on_del
        if value is not None:
            self.set_value(value, env)
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        self.release()
    
    def __str__(self):
        return str(self.get_value())
    
    def __repr__(self):
        return repr(self.get_value())
    
    # set methods
    
    def set_value(self, value, env=None):
        if   isinstance(value, bool):       self.set_bool(value)
        elif isinstance(value, int):        self.set_int(value)
        elif isinstance(value, float):      self.set_float(value)
        elif isinstance(value, basestring): self.set_string(value, env)
        elif isinstance(value, AVS_Clip):   self.set_clip(value)
        elif isinstance(value, AVS_Value):  self.copy_from(value)
        elif isinstance(value, ffi.CData):  self.set_cdata(value)
        elif isinstance(value, collections.Iterable): self.set_array(value)
        else:
            raise AvisynthError('invalid type: {type}'.format(type=type(value)))
    
    def __call__(self, val, env=None):
        self.set_value(val, env)
    
    def copy_from(self, value):
        avs.avs_copy_value_w(self.cdata, value.cdata)
        self.env = value.env
        self._release_on_del = value._release_on_del
    
    def set_void(self):
        self.copy_from(avs_void)
    
    def set_cdata(self, value):
        if self.is_defined():
            self.release()
        self.cdata = value
    
    def set_bool(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_bool_w(value, self.cdata)
    
    def set_int(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_int_w(value, self.cdata)
    
    def set_float(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_float_w(value, self.cdata)
    
    def set_string(self, value, env=None):
        if self.is_defined():
            self.release()
        if isinstance(value, unicode):
            # mbcs will replace invalid characters anyway
            value = value.encode(encoding, 'backslashreplace')
        chars = ffi.new('char[]', value)
        env = env or self.env
        if isinstance(env, AVS_ScriptEnvironment):
            chars = env.save_string(chars)
        avs.avs_new_value_string_w(chars, self.cdata)
    
    def set_error(self, value, env=None):
        if self.is_defined():
            self.release()
        if isinstance(value, unicode):
            value = value.encode(encoding, 'backslashreplace')
        chars = ffi.new('char[]', value)
        env = env or self.env
        if isinstance(env, AVS_ScriptEnvironment):
            chars = env.save_string(chars)
        avs.avs_new_value_error_w(chars, self.cdata)
    
    def set_clip(self, value):
        if self.is_defined():
            self.release()
        avs.avs_new_value_clip_w(value.cdata, self.cdata)
    
    def set_array(self, values, env=None):
        if self.is_defined():
            self.release()
        env = env or self.env
        length = len(values)
        avs_values = ffi.new('AVS_Value []', length)
        for i, value in enumerate(values):
            if not isinstance(value, AVS_Value):
                value = AVS_Value(value, env)
            avs.avs_copy_value_w(ffi.addressof(avs_values[i]), value.cdata)
        avs.avs_new_value_array_w(avs_values, length, self.cdata)
    
    # check type methods
    
    def is_defined(self):
        return bool(avs.avs_defined_w(self.cdata))
    
    def get_type(self):
        if self.is_bool():
            type = 'bool'
        elif self.is_int():
            type = 'int'
        elif self.is_float():
            type = 'float'
        elif self.is_string():
            type = 'string'
        elif self.is_error():
            type = 'error'
        elif self.is_clip():
            type = 'clip'
        elif self.is_array():
            type = 'array'
        else:
            type = None
        return type
    
    def is_bool(self):
        return bool(avs.avs_is_bool_w(self.cdata))
    
    def is_int(self):
        return bool(avs.avs_is_int_w(self.cdata))
    
    def is_float(self):
        return bool(avs.avs_is_float_w(self.cdata))
    
    def is_string(self):
        return bool(avs.avs_is_string_w(self.cdata))
    
    def is_error(self):
        return bool(avs.avs_is_error_w(self.cdata))
    
    def is_clip(self):
        return bool(avs.avs_is_clip_w(self.cdata))
    
    def is_array(self):
        return bool(avs.avs_is_array_w(self.cdata))
    
    # get methods
    
    def get_value(self, env=None):     
        if   self.is_bool():   return self.as_bool()
        elif self.is_int():    return self.as_int()
        elif self.is_float():  return self.as_float()
        elif self.is_string(): return self.as_string()
        elif self.is_error():  return self.as_error()
        elif self.is_clip():   return self.as_clip(env)
        elif self.is_array():  return self.as_array(env)
    
    def as_bool(self):
        if self.is_bool():
            bool(avs.avs_as_bool_w(self.cdata))
        else:
            raise AvisynthError('Not a bool')
    
    def as_int(self):
        if self.is_int():
            return avs.avs_as_int_w(self.cdata)
        else:
            raise AvisynthError('Not an int')
    
    def as_float(self):
        if self.is_float():
            return avs.avs_as_float_w(self.cdata)
        else:
            raise AvisynthError('Not a float')
    
    def as_string(self):
        if self.is_string():
            chars = avs.avs_as_string_w(self.cdata)
            if chars == ffi.NULL:
                return ''
            return ffi.string(chars)
        else:
            raise AvisynthError('Not a string')
    
    def as_error(self):
        if self.is_error():
            chars = avs.avs_as_error_w(self.cdata)
            if chars == ffi.NULL:
                return ''
            return ffi.string(chars)
        else:
            raise AvisynthError('Not an error')
    
    def as_clip(self, env=None):
        if self.is_clip():
            env = env or self.env
            if not isinstance(env, AVS_ScriptEnvironment):
                raise AvisynthError('AVS_Value.as_clip needs an environment')
            return AVS_Clip(avs.avs_take_clip_w(self.cdata, env.cdata))
        else:
            raise AvisynthError('Not a clip')
    
    def as_array(self, env=None):
        if self.is_array():
            return [self.array_elt(i, env) for i in range(self.array_size())]
        else:
            raise AvisynthError('Not an array')
    
    def array_size(self):
        return self.cdata.array_size if self.is_array() else 1
    
    def array_elt(self, index, env=None):
        if not 0 <= index < self.array_size():
            raise IndexError 
        return AVS_Value(avs.avs_array_elt_w(self.cdata, index), 
                         env=env or self.env, release_on_del=False).get_value()
    
    def __len__(self):
        return self.array_size()
    
    def __getitem__(self, index):
        if isinstance(index, slice):
            pass # TODO
        else:
            return self.array_elt(index)
    
    # free memory
    
    def release(self):
        if self.is_array():
            for index in range(self.array_size()):
                avs.avs_release_value_w(avs.avs_array_elt_w(self.cdata, index))
        avs.avs_release_value_w(self.cdata)
        if self.is_defined():
            self.set_void()
    
    def __del__(self):
        if self._release_on_del:
            self.release()


class AVS_Clip(object):
    
    def __init__(self, clip):
        self.cdata = clip
        self._error = None # additional error info
    
    def __del__(self):
        avs.avs_release_clip(self.cdata)
    
    def copy_clip(self):
        return avs.avs_copy_clip(self.cdata)
    
    def get_error(self):
        err = avs.avs_clip_get_error(self.cdata)
        if err == ffi.NULL:
            err = self._error
        else:
            err = ffi.string(err)
        self._error = None # avs_clip_get_error is used for more than get_frame
        return err
    
    def get_video_info(self):
        return AVS_VideoInfo(avs.avs_get_video_info(self.cdata))
    
    def get_version(self):
        return avs.avs_get_version(self.cdata)
    
    def get_frame(self, n):
        # The returned video frame must be released with avs_release_video_frame
        self._error = None
        try:
            return AVS_VideoFrame(avs.avs_get_frame(self.cdata, n))
        except Exception as err: # crashes
            # Clear the exception traceback in order to avoid keeping an 
            # additional reference to the clip, which would cause its 
            # destruction to be postponed until the process finishes (if 
            # that's the last exception). It would then cause a new exception 
            # as the env doesn't exist anymore at that point (maybe even 
            # avisynth was already unloaded).
            self._error = ''.join(traceback.format_exception_only(type(err), err))
            sys.exc_clear()
    
    def get_parity(self, n):
        """return field parity if field_based, else parity of first field in frame"""
        return avs.avs_get_parity(self.cdata, n)
    
    def get_audio(self, buf, start, count):
        # start and count are in samples
        return avs.avs_get_audio(self.cdata, buf, start, count)
    
    def set_cache_hints(self, cachehints, frame_range):
        return avs.avs_set_cache_hints(self.cdata, cachehints, frame_range)


class AVS_ScriptEnvironment(object):
    
    def __init__(self, version=3):
        self.cdata = avs.avs_create_script_environment(version)
    
    def __del__(self):
        avs.avs_delete_script_environment(self.cdata)
    
    def get_error(self): # XXX: only on interface 5
        err = avs.avs_get_error(self.cdata)
        if err == ffi.NULL:
            return None
        return ffi.string(err)
    
    def get_cpu_flags(self):
        return avs.avs_get_cpu_flags(self.cdata)
    
    def check_version(self, version):
        # 0 -> True, -1 -> False
        return not avs.avs_check_version(self.cdata, version)
    
    def save_string(self, chars):
        return avs.avs_save_string(self.cdata, chars, len(chars))
    
    def sprintf(self, fmt, *args): # every arg must be ffi.CData
        chars = avs.avs_sprintf(self.cdata, fmt, *args)
        if chars == ffi.NULL:
            return ''
        return ffi.string(chars)
    
    def vsprintf(self, fmt, val): # TODO (never)
        # note: val is really a va_list; I hope everyone typedefs va_list to a pointer
        chars = avs.avs_vsprintf(self.cdata, fmt, val)
        if chars == ffi.NULL:
            return ''
        return ffi.string(chars)
    
    def function_exists(self, name):
        return bool(avs.avs_function_exists(self.cdata, name))
    
    def invoke(self, name, args=[], arg_names=None):
        # args needs to be an iterable
        if not isinstance(args, AVS_Value):
            args = AVS_Value(args, env=self)
        if arg_names is None:
            arg_names = ffi.NULL
        else:
            if isinstance(arg_names, basestring):
                arg_names = [arg_names]
            arg_names2 = [ffi.new('char[]', name) for name in arg_names]
            arg_names = ffi.new('char*[]', arg_names2)
        ret = AVS_Value(env=self)
        avs.avs_invoke_w(self.cdata, name, args.cdata, arg_names, ret.cdata)
        if ret.is_error():
            raise AvisynthError(ret.as_error())
        return ret.get_value()
    
    def get_var(self, name, type=False):
        if isinstance(name, unicode):
            name = name.encode(encoding, 'backslashreplace')
        value = AVS_Value(env=self)
        avs.avs_get_var_w(self.cdata, name, value.cdata)
        if value.get_type() is None:
            raise AvisynthError('NotFound')
        if type:
            return value.get_value(), value.get_type()
        return value.get_value()
    
    def set_var(self, name, value):
        if not isinstance(value, AVS_Value):
            value = AVS_Value(value, self)
        return avs.avs_set_var_w(self.cdata, name, value.cdata)
    
    def set_global_var(self, name, value):
        if not isinstance(value, AVS_Value):
            value = AVS_Value(value, self)
        return avs.avs_set_global_var_w(self.cdata, name, value.cdata)
    
    def new_video_frame_a(self, vi, align=avs.AVS_FRAME_ALIGN):
        # align should be at least 16
        return avs.avs_new_video_frame_a(self.cdata, vi, align)
    
    def make_writable(self, video_frame):
        video_frame_p = ffi.new('AVS_VideoFrame * *', video_frame.cdata)
        ret = avs.avs_make_writable(self.cdata, video_frame_p) 
        video_frame.cdata = video_frame_p[0]
        return ret
    
    def bit_blt(self, dstp, dst_pitch, srcp, src_pitch, row_size, height):
        avs.avs_bit_blt(self.cdata, dstp, dst_pitch, srcp, src_pitch, row_size, height)
    
    def subframe(self, video_frame, rel_offset, new_pitch, new_row_size, new_height):
        return avs.avs_subframe(self.cdata, video_frame.cdata, rel_offset, 
                                new_pitch, new_row_size, new_height)
    
    def subframe_planar(self, video_frame, rel_offset, new_pitch, new_row_size, 
                        new_height, rel_offsetU, rel_offsetV, new_pitchUV):
        return avs.avs_subframe_planar(self.cdata, video_frame.cdata, 
                        rel_offset, new_pitch, new_row_size, new_height, 
                        rel_offsetU, rel_offsetV, new_pitchUV)
        
    def set_memory_max(self, memory):
        return avs.avs_set_memory_max(self.cdata, memory)
    
    def set_working_dir(self, new_dir):
        if isinstance(new_dir, unicode):
            new_dir = new_dir.encode(encoding, 'backslashreplace')
        return avs.avs_set_working_dir(self.cdata, new_dir)


class AvisynthError(Exception):
    pass

if not abi:
    # TODO: find out why 'avs' is None for 'avs_void'
    avs_void = AVS_Value(release_on_del=False)


def test():

    env = AVS_ScriptEnvironment(3)
    print 'environment created:', env
    err = env.get_error()
    if err is not None:
        print 'error:', err
        return
    print 'checking for interface 3:', env.check_version(3)
    print 'checking for interface 33:', env.check_version(33)
    
    if abi:     # libffi doesn't support passing structs or unions
        return  # with bit-fields by value
    
    print 'interface:', avs.AVISYNTH_INTERFACE_VERSION
    print env.invoke('VersionString')
    
    print '\nsome internal functions...'
    for function_name in env.get_var('$InternalFunctions$').split()[:10]:
        try:
            params = env.get_var('$Plugin!' + function_name + '!Param$')
        except AvisynthError, err:
            if str(err) != 'NotFound': raise
        else:
            print ' ', function_name, params
    var_name, value = 'test var', 'some text'
    print '\nsetting a string variable with value {0}'.format(repr(value))
    env.set_var(var_name, value)
    print 'value retrieved:', repr(env.get_var(var_name)) # check save_string
    print '\ninvoking...'
    try:
#        ret = env.invoke('Version')
        ret = env.invoke('BlankClip', [100, 200, 300])
#        ret = env.invoke('Eval', 
#                         ['assert(false, "assert message")', 'script title'])
    except AvisynthError, err:
        print 'error:', env.get_error()
    else:
        if isinstance(ret, AVS_Clip):
            clip = ret
            AVS_Value(AVS_Value(clip, env), env).get_value() # test passing clip
            print clip.get_video_info()
            frame = clip.get_frame(5)
            err = clip.get_error()
            if err:
                print 'error:', err
            else:
                print frame
                frame.get_read_ptr()[0:20]
        else:
            print 'value:', ret

if __name__ == '__main__':
    test()
